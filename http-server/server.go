package main

import (
	"crypto/tls"   // Core package for Transport Layer Security
	"crypto/x509"  // Package for parsing X.509 certificates (needed for mTLS)
	"fmt"
	"log"
	"net/http"     // Standard library for HTTP servers
	"os"

	"golang.org/x/net/http2" // Support for HTTP/2 features
)

/**
 * FUTURE REFERENCE: mTLS LOGIC
 * ----------------------------
 * Standard TLS: Only the Server proves its identity to the Client.
 * mTLS (Mutual): Both the Server AND the Client prove identities to each other.
 * This code forces the client to present a certificate that this server trusts.
 */

// loadClientCAs: Setup the "Trust Store"
func loadClientCAs(caPath string) *x509.CertPool {
	// 1. Create an empty Certificate Pool
	clientCAs := x509.NewCertPool()

	// 2. Read the Certificate Authority (CA) file from disk
	caCert, err := os.ReadFile(caPath)
	if err != nil {
		log.Fatalf("FILE ERROR: Cannot find %s. Did you run the openssl command? %v", caPath, err)
	}

	// 3. Parse the PEM encoded data and add it to our pool of trusted certs
	ok := clientCAs.AppendCertsFromPEM(caCert)
	if !ok {
		log.Fatal("PARSE ERROR: cert.pem exists but is not a valid PEM certificate.")
	}

	return clientCAs
}

func main() {
	// --- ROUTING ---

	// Default Route: Tests if the server is alive
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		logRequestDetails(r)
		fmt.Fprintln(w, "Auth Success: You are connected via mTLS!")
	})

	// Secondary Route: Example of a protected resource
	http.HandleFunc("/orders", func(w http.ResponseWriter, r *http.Request) {
		logRequestDetails(r)
		fmt.Fprintln(w, "Access Granted: Viewing secure order data.")
	})

	// --- TLS & SERVER CONFIGURATION ---

	const port = "3000"
	certFile := "cert.pem" // Path to the public certificate
	keyFile := "key.pem"   // Path to the private key (Keep this secret!)

	// Define the security rules for the connection
	tlsConfig := &tls.Config{
		// Force modern security; TLS 1.0 and 1.1 are considered insecure/deprecated
		MinVersion: tls.VersionTLS12,

		// REQUIRE: The server will reject any client that does not send a certificate
		// VERIFY: The server will check the client certificate against the 'ClientCAs' pool
		ClientAuth: tls.RequireAndVerifyClientCert,

		// The list of Root CAs that the server uses to verify client identities
		ClientCAs: loadClientCAs(certFile),

		// Optimization: Server chooses the fastest/most secure cipher common to both parties
		PreferServerCipherSuites: true,
	}

	// Initialize the Server object with our custom security settings
	server := &http.Server{
		Addr:      ":" + port,
		TLSConfig: tlsConfig,
		Handler:   nil, // Use http.DefaultServeMux (the handlers registered above)
	}

	// Explicitly enable HTTP/2 support (required for modern high-performance Go apps)
	if err := http2.ConfigureServer(server, &http2.Server{}); err != nil {
		log.Fatalf("H2 ERROR: Could not configure HTTP/2: %v", err)
	}

	fmt.Printf("ðŸš€ mTLS Server active at https://localhost:%s\n", port)
	fmt.Println("Note: Clients must provide a valid certificate to connect.")

	// Start the server using the cert and key generated by your OpenSSL command
	err := server.ListenAndServeTLS(certFile, keyFile)
	if err != nil {
		log.Fatalln("STARTUP ERROR: Server failed to start:", err)
	}
}

// logRequestDetails: Inspects the "Handshake" to see what security was used
func logRequestDetails(r *http.Request) {
	// Proto shows "HTTP/2.0" or "HTTP/1.1"
	fmt.Printf("[%s] %s Request\n", r.Method, r.Proto)

	if r.TLS != nil {
		// Log the version (e.g., TLS 1.3)
		versionName := getTLSVersionName(r.TLS.Version)
		fmt.Printf("  -> Encryption: %s\n", versionName)

		// Check the client's identity (the 'Common Name' or CN)
		if len(r.TLS.PeerCertificates) > 0 {
			clientCN := r.TLS.PeerCertificates[0].Subject.CommonName
			fmt.Printf("  -> Client ID (CN): %s\n", clientCN)
		}
	} else {
		fmt.Println("  -> !! INSECURE CONNECTION !! No TLS detected.")
	}
}

// Helper: Converts Go's internal TLS constants (uint16) to readable strings
func getTLSVersionName(version uint16) string {
	switch version {
	case tls.VersionTLS10: return "TLS 1.0"
	case tls.VersionTLS11: return "TLS 1.1"
	case tls.VersionTLS12: return "TLS 1.2"
	case tls.VersionTLS13: return "TLS 1.3"
	default:               return "Unknown/Obsolete"
	}
}